<!DOCTYPE html>
<link rel="import" href="bower_components/polymer/polymer.html">
<link rel="import" href="bower_components/core-elements/core-elements.html">
<!--

  A non-visual slideable element whose motion has a bit of resistance to the
  physical touch input shoving it around.

  TODO:
    - implement option to animate rather than skip pixels
    - figure out initial jank

  Attributes:
    min: string value for translateX at beginning (default 0%)
    max: string value for translateX at end (default 100%)
    snapPoints: list of values to snap to. Default to none, but set to same
                values as min/max to animate to them when released
    skew: scale inputs by this value, slows everything down. Note if this is
                < 1 the user can't drag all the way to the max value (default
                is 0.9)
 -->
<polymer-element name="x-inertial-slider" touch-action="pan-y" on-trackstart="{{gestureStart}}" on-trackend="{{gestureEnd}}" on-track="{{gestureTrack}}" attributes="resistance touchElement useImplAnimation snapPoints snapAnimDuration min max">
  <template>
    <style>
      :host {
        display: block;
      }
      #log {
        position: absolute;
        z-index: 1000;
        bottom: 10px;
      }
      #offsetContainer {
        will-change: transform;
        transform: translateX({{min}});
      }
    </style>
    <div id="slideContainer">
      <div id="offsetContainer">
        <content></content>
      </div>
    </div>
    <div id="log"></div>
  </template>
  <script>
    Polymer('x-inertial-slider', {
      // controls resolution of the animation; set high to avoid rounding
      skew: 0.9,
      //acceptableTimingSkew_: 20,   //TODO don't make this constant
      snappiness_: 20,
      dragDuration_: 5000,
      dragBeginTimeline_: 0,
      dragBeginCoordinate_: 0,
      min: '0%',
      max: '100%',
      logTag_: '\[inertial-slider\]',
      log_: function(str) {
        console.log(this.logTag_, str);
      this.$.log.innertHTML += str + '<br/>';
      },
      ready: function() {
        if(!this.snapPoints) {
          this.snapPoints = null;
        }
        // additional property initialization
        this.easing_ = 'cubic-bezier(0.425, 0.965, 0.590, 1.015)';
        this.dragPlayer_ = null;
      },
      gestureStart: function(e, detail, sender) {
        this.log_('beginning slide gesture');
        // If there isn't a drag in progress, start a new animation
        if(!this.dragPlayer_) {
          var keyframes = [
            { transform: 'translateX(' + this.min + ')' },
            { transform: 'translateX(' + this.max + ')' }
            ];
          var animationTiming = {
            duration: this.dragDuration_,
            fill: 'both',
            easing: this.easing_,
          };
          this.dragPlayer_ = this.$.offsetContainer.animate(keyframes,
              animationTiming);
        }
        // Using either the new animation or the existing one, reset
        // where this drag has begun from. Use pageX to support events
        // outside of the target
        this.dragBeginCoordinate_ = e.pageX;
        this.dragBeginTimeline_ = this.dragPlayer_.currentTime;
        this.dragPlayer_.playbackRate = 1;
        this.dragPlayer_.play();
      },
      gestureEnd: function(e, detail, sender) {
        this.log_('ending gesture');
        e.preventTap(); //TODO is this still needed?
        if(this.dragPlayer_.currentTime != 0) {
          if(this.dragPlayer_.playbackRate > 0) {
            this.dragPlayer_.reverse();
            this.log_('reversing');
          }
          // set the playback rate such that the thing 'snaps back'
          this.dragPlayer_.playbackRate = this.dragPlayer_.playbackRate*15;
          this.dragPlayer_.play();
        }
      },
      gestureTrack: function(e, detail, sender) {
        // track the touch drag along the box's predefined translate animation
        var dragOffset = e.pageX - this.dragBeginCoordinate_;
        //TODO strictly speaking this should use page width not screen width
        var timelineOffset =
          (dragOffset / window.screen.width) *
          this.dragDuration_;
        var targetTime =
            (this.dragBeginTimeline_ + timelineOffset) * this.skew
        // clamp the values of currentTime to the valid animation range
        if(targetTime < 0) {
          targetTime = 0;
          }
        if(targetTime > this.dragDuration_) {
          targetTime = this.dragDuration_;
          }

        /* Nice idea, but doesn't quite work.
        // if the target time would jump the animation ahead significantly
        // catch up instead
        var timingSkew = Math.abs(targetTime - this.dragPlayer_.currentTime);
        if(timingSkew > this.acceptableTimingSkew_) {
          if(this.dragPlayer_.paused) {
            this.log_('animating due to unacceptable timing skew of ' + timingSkew);
            this.dragPlayer_.playbackRate = 8;
            this.dragPlayer_.play();
          }
        }
        // if the target time isn't far away, just seek there
        else {
        }
        */
        this.dragPlayer_.pause();
        this.dragPlayer_.playbackRate = 1;
        this.dragPlayer_.currentTime = targetTime;

        // (just some logging)
        if(!this.lastTrack_) this.lastTrack_ = this.dragBeginCoordinate_;
        this.log_('tracking physically to ' + e.pageX + ' from ' + this.lastTrack_ +
                  ' (diff ' + (e.pageX - this.lastTrack_) + ')');
        this.log_('tracking animation to ' + this.dragPlayer_.currentTime);
        this.lastTrack_ = e.pageX;
      },
    });
  </script>
</polymer-element>
