<!DOCTYPE html>
<link rel="import" href="bower_components/polymer/polymer.html">
<link rel="import" href="bower_components/core-elements/core-elements.html">
<link rel="import" href="bower_components/paper-elements/paper-elements.html">
<polymer-element name="x-flickr-shadowbox" on-down="{{shadowGestureDown}}" touch-action="pan-y" on-trackstart="{{shadowGestureStart}}" on-trackend="{{shadowGestureEnd}}" on-track="{{shadowGestureTrack}}" on-tap="{{shadowTap}}" attributes="photoModel">
  <template>
    <style>
      :host {
        display: block;
      }
      #shadowbox {
        box-sizing: border-box;
        height: 344px;        /* TODO make this an attribute */
        margin-left: 16px;
        margin-top: 8px;
        margin-right: 16px;
      }
      #touchContainer {
        height: 100%;
        -webkit-transform-style: preserve-3d;
        position: relative;
      }
      #shadowbox .front {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      #shadowbox.interaction .front {
        backface-visibility: hidden;
      }
      #shadowbox .back {
        position: absolute;
        top: 0;
        left: 0;
        background-color: teal;
        width: 100%;
        height: 100%;
        overflow: hidden;
        backface-visibility: hidden;
        transform: rotateY(180deg);
        display: none;
      }
      #shadowbox.interaction div.back {
        display: block;
      }
      .header-img {
        height: 220px;
        overflow: hidden;
      }
      .header-img .img {
        width: 100%;
      }
      #description {
        margin: 8px;
        text-overflow: ellipsis;
        white-space: nowrap;
        overflow: hidden;
        height: 100%;
      }
    </style>

    <div id="shadowbox" class="interaction">
      <div id="touchContainer">
        <paper-shadow z="1"></paper-shadow>
        <div class="back">
          this is the back
        </div>
        <div class="front" layout vertical>
          <div class="header-img">
            <img src="{{ photoModel.url_m }}" />
          </div>
          <h3>{{title}}</h3>
          <div id="description" class="description" flex>
          </div>
        </div>
      </div>
    </div>
  </template>
  <script>
    Polymer('x-flickr-shadowbox', {
      dragDuration_: 750,
      photoModelChanged: function(oldVal, newVal) {
        this.$.description.innerHTML = newVal.description._content;
      },
      ready: function() {
      },
      shadowTap: function(e, detail, sender) {
        //this.$.shadowbox.classList.add('interaction');
        //FIXME lame timer-based approach to not tapping if you were just dragging
        if(Date.now() - this.lastDrag < 100
            || this.dragPlayer && this.dragPlayer.currentTime > 0) {
          console.log('early out from tap');
          return;
        }
        if(this.rotationPlayer) {
          console.log('rotating');
          this.rotationPlayer.reverse();
          if(this.rotationPlayer.finished) {
            this.rotationPlayer.play();
            }
          return;
        }
        console.log('starting rotation animation');
        this.rotationPlayer = this.$.touchContainer.animate(
          [{ transform: 'rotateY(0deg);' },
           { transform: 'rotateY(180deg);' }],
          {
            duration: 500,
            fill: "both"
          }
          );
      },
      shadowGestureTrack: function(e) {
        var dragOffset = e.pageX- this.dragBeginLocation;
        var timelineOffset =
          (dragOffset / window.screen.width) * this.dragDuration_;
        this.dragPlayer.currentTime = this.timelineBegin + timelineOffset;
        // clamp the values of currentTime to the valid animation range
        if(this.dragPlayer.currentTime < 0) {
          this.dragPlayer.currentTime = 0;
          }
        if(this.dragPlayer.currentTime > this.dragDuration_) {
          this.dragPlayer.currentTime = 2000;
          }
        if(!this.lastTrack) this.lastTrack=0;
        console.log('tracking by',
            360*0.25*(timelineOffset - this.lastTrack)/this._dragDuration);
        this.lastTrack = timelineOffset;
        //TODO if hit the end of the animation, do thing
      },
      shadowGestureStart: function(e, detail, sender) {
        //this.$.shadowbox.classList.add('interaction');
        console.log('beginning gesture on ', sender);
        // If there isn't a drag in progress, start a new animation
        if(!this.dragPlayer) {
          var keyframes = [
            { transform: 'translateX(0)' },
            { transform: 'translateX(25%)' }
            ];
          this.dragPlayer = this.$.shadowbox.animate(keyframes,
                                                     { duration: this.dragDuration_,
                                                       fill: 'both',
                                                       easing: 'ease-out'
                                                     });
        }
        // Using either the new animation or the existing one, reset
        // where this drag has begun from.
        this.dragBeginLocation = e.pageX;
        this.timelineBegin = this.dragPlayer.currentTime;
        this.dragPlayer.pause();
      },
      shadowGestureEnd: function(e, detail, sender) {
        this.lastDrag = e.timeStamp;
        console.log('ending gesture');
        if(this.dragPlayer.currentTime == 0) {
          return;
        }
        if(this.dragPlayer.playbackRate > 0) {
          this.dragPlayer.reverse();
          console.log('reversing');
        }
        this.dragPlayer.play();
      }
    });
  </script>
</polymer-element>
